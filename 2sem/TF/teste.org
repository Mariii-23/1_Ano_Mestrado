#+title: Teste

* Teste 16 de maio de 2022
** 1
#+begin_quote
Qual a necessidade de definirmos um modelo de computação e de faltas na resolução de um problema de sistemas distribuídos. Recorra a exemplos se lhe facilitar a exposição
#+end_quote

A definição de um modelo de computação e um modelo de faltas é fundamental na resolução de problemas em sistemas distribuídos. Esses modelos ajudam a estabelecer as suposições e restrições do ambiente em que o sistema distribuído opera, permitindo que os algoritmos e protocolos sejam projetados de forma adequada.


- Um modelo de computação :: define como os nós do sistema distribuído interagem e se comunicam entre si. Ele especifica as características do ambiente de execução, incluindo o tipo de comunicação entre os nós, a latência da rede, a ordem de entrega das mensagens e a sincronização de relógios, entre outros aspectos.

- Um modelo de faltas :: define os tipos de falhas que podem ocorrer nos nós do sistema distribuído. Essas falhas podem incluir nós que param de responder, transmissões de mensagens perdidas, latência excessiva na rede ou até mesmo nós que se comportam de maneira maliciosa. Ao especificar o modelo de faltas, os desenvolvedores podem projetar algoritmos e protocolos para lidar com essas falhas de maneira adequada.


- Exemplo ::  Considere um sistema distribuído que precisa realizar a eleição de um líder entre os nós participantes. O modelo de computação pode especificar se os nós podem se comunicar diretamente ou se precisam passar por um processo de comunicação indireta, como o envio de mensagens por meio de um canal de broadcast. O modelo de faltas, por sua vez, pode especificar se os nós podem falhar de forma silenciosa, interrompendo completamente a comunicação, ou se podem se comportar de maneira maliciosa, enviando mensagens falsas. Com base nessas definições, podem ser projetados algoritmos de eleição que sejam adequados para o ambiente em questão, considerando as restrições e as ameaças potenciais.

Em resumo, a definição de um modelo de computação e um modelo de faltas é essencial para projetar algoritmos e protocolos eficientes e seguros em sistemas distribuídos. Eles ajudam a estabelecer as suposições e restrições do ambiente de execução, permitindo que os desenvolvedores enfrentem os desafios específicos desse tipo de sistema.

(podia se referir too que os modelos permitem-nos perceber se os problemas tem solucao e qual o custo delas)

** 2

#+begin_quote
Explique porque recorremos à utilização de diferentes quoruns na replicação de dados?
#+end_quote

A utilização de diferentes quóruns na replicação de dados tem como objetivo equilibrar trade-offs em relação a disponibilidade, consistência e desempenho do sistema. Quóruns são conjuntos de réplicas que precisam responder a uma operação de leitura ou escrita para que ela seja considerada bem-sucedida.

Existem duas principais razões para o uso de diferentes quóruns:

- Tolerância a falhas :: Ao utilizar diferentes quóruns, é possível aumentar a tolerância a falhas do sistema. Por exemplo, um quórum pode ser configurado para incluir a maioria das réplicas disponíveis. Se algumas réplicas falharem, ainda será possível obter a maioria dos votos e realizar operações de leitura e escrita. Isso aumenta a disponibilidade do sistema, garantindo que ele continue funcionando mesmo na presença de falhas.

- Consistência e desempenho :: O uso de diferentes quóruns também permite ajustar a consistência e o desempenho do sistema de acordo com os requisitos específicos. Por exemplo, um quórum de leitura pode ser configurado para incluir apenas algumas réplicas, o que resulta em leituras mais rápidas, mas potencialmente menos consistentes, já que as réplicas podem não ter a versão mais recente dos dados. Por outro lado, um quórum de escrita pode ser configurado para exigir um número maior de réplicas, garantindo uma maior consistência dos dados, mas com um impacto potencial no desempenho devido à necessidade de esperar pela confirmação de um maior número de réplicas.

Dessa forma, a utilização de diferentes quóruns permite ajustar o equilíbrio entre disponibilidade, consistência e desempenho de acordo com as necessidades e requisitos específicos do sistema distribuído em questão. É importante encontrar um equilíbrio adequado que atenda aos objetivos do sistema e ofereça a combinação correta de tolerância a falhas, consistência dos dados e desempenho.

** 3
#+begin_quote
Considere o algoritmo Raft. O processo falha enquanto líder e op é a última operação que faz commit. Como assegura o algoritmo que o líder seguinte tem op no seu log antes de fazer commit a outra operação?
#+end_quote

No algoritmo de Raft, o líder deverá, inevitavelmente, guardar todas as entradas que foram commited até ao momento e assegurar que todas as entradas que foram commited em termos anteriores estarão presentes num novo líder desde o momento da sua eleição.


Quando um líder falha, inicia-se o processo de eleição para escolher-se um novo líder. Desta forma um nó candidato envia ~RequestVote RPC~ a todos os outros nós e somente quando este alcança a maioria de votos é que este se torna líder.

No entanto, um nó (Follower) só irá aceitar o pedido de ~RequestVote~ de um candidato se este verificar que o log desse candidato está igual ou mais atualizado do que o seu próprio log.
(Se a ultima entrada de um log tiver um term diferente da ultima entrada do outro, entao o log com o termo mais elevado esta mais atualizado. Se ambos terminarem com uma entrada com o mesmo mandato, entao o llog com maior comprimento é o mais atualizado.)

Uma vez que uma entrada commited estará presente numa maioria dos nodos e o candidato precisa de uma maioria dos nodos para ganhar a eleição, garantimos que o candidato apenas será eleito se tiver todas as entradas que foram commited (operações anteriores, incluindo a operação ~op~).

Dessa forma, após este ser eleito, temos a garantia que este tem conhecimento sobre a operação ~op~ antes de efetuar um qualquer  commit a outra operação.

** 4
#+begin_quote
Explique sucintamente os dois algoritmos de ordenacao total de mensagens apresentados nas aulas.
#+end_quote

- Consensus (Acordo) :: O algoritmo de Consensus é usado para alcançar um acordo entre vários participantes de um sistema distribuído sobre um valor ou sequência de valores. Este garante que todos os nós no sistema cheguem a um consenso sobre a decisão a ser tomada. O algoritmo de Consensus pode ser usado para ordenar mensagens, decidindo a sequência em que estas devem ser entregues. Um exemplo de algoritmo de Consensus é o algoritmo Raft, onde os nós participantes votam para eleger um líder que toma as decisões e coordena a ordenação das mensagens.

- Atomic Broadcast :: É um algoritmo que garante que as mensagens são entregues a todos os nós do sistema de forma atômica e pela mesma ordem sem que nenhuma mensagem seja perdida ou entregue de forma inconsistente. Este algoritmo é usado para estabelecer uma ordenação total de mensagens nos sistemas distribuídos.


Em resumo, o algoritmo de Consensus é usado para alcançar um acordo sobre um valor ou sequência de valores, que pode ser utilizado para ordenar as mensagens. Já o algoritmo de Atomic Broadcast garante que as mensagens sejam entregues a todos os nós de forma atômica e na mesma ordem, estabelecendo uma ordenação total das mensagens no sistema distribuído. Ambos os algoritmos desempenham um papel fundamental na garantia da consistência e ordenação correta das operações em sistemas distribuídos.

