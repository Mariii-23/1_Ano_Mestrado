#+title: Readme

* Exercise 1
a) Compilation process: Use -XX:+PrintCompilation in program execution to identify the methods which were compiled to native instructions. How many times was mmult compiled? Why?
    #+begin_src bash
> java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly MULT > MULT.s
> cat MULT.s | grep mmult

ImmutableOopMap{}pc offsets: 1668 1680 1692 1704 1716 1728 1740 1768 1796 Compiled method (c1)      59   71 %     3       MULT::mmult @ 24 (73 bytes)
ImmutableOopMap{}pc offsets: 1077 1110 1143 Compiled method (c2)      64   72 %     4       MULT::mmult @ 24 (73 bytes)
ImmutableOopMap{}pc offsets: 1128 1144 1160 Compiled method (c1)      65   73 %     3       MULT::mmult @ 24 (73 bytes)
ImmutableOopMap{}pc offsets: 1077 1110 1143 Compiled method (c2)      70   74 %     4       MULT::mmult @ 24 (73 bytes)
    #+end_src

    O código foi compilado 4 vezes.

    #+begin_src bash
> java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly MULT > MULT.s
> cat MULT.s | grep MULT

ImmutableOopMap{}pc offsets: 288 300 Compiled method (c1)      50   68 %     3       MULT::init @ 17 (57 bytes)
ImmutableOopMap{rax=Oop }pc offsets: 2169 Compiled method (c1)      50   69       3       MULT::init (57 bytes)
ImmutableOopMap{[208]=Oop }pc offsets: 1989 2022 Compiled method (c2)      57   70 %     4       MULT::init @ 17 (57 bytes)
ImmutableOopMap{}pc offsets: 1668 1680 1692 1704 1716 1728 1740 1768 1796 Compiled method (c1)      59   71 %     3       MULT::mmult @ 24 (73 bytes)
ImmutableOopMap{}pc offsets: 1077 1110 1143 Compiled method (c2)      64   72 %     4       MULT::mmult @ 24 (73 bytes)
ImmutableOopMap{}pc offsets: 1128 1144 1160 Compiled method (c1)      65   73 %     3       MULT::mmult @ 24 (73 bytes)
ImmutableOopMap{}pc offsets: 1077 1110 1143 Compiled method (c2)      70   74 %     4       MULT::mmult @ 24 (73 bytes)
    #+end_src

    R: 3

b) Identify code executed: In the MULT.s file, students will find the assembly code generated by the JIT during program execution. The perfreport.txt file contains the execution profile of the same run. Identify the assembly code that was executed.

   #+begin_src bash
>  cat MULT.s | grep 0x00007f194912fa90

0x00007f194912fa90: mov    0x10(%rdi,%rcx,4),%eax  ;*aaload
                                                ; - MULT::mmult@48 (line 29)

0x00007f194912faf1: jl     0x00007f194912fa90  ;*if_icmpge
                                                ; - MULT::mmult@26 (line 28)
  #+end_src

    Segundo o stor a "máquina decidiu fazer o unrolling 2 vezes".

c) Analyse code: The Java program requires more instructions than C program to perform the matrix multiplication. Analyse assembly code generated from Java (kernel of matrix multiplication) and identify optimisations present in the code. These optimisations were also applied in the C version?

d) Measure compiler impact: Open the file perfreport2.txt and analyse if there is a negative impact of dynamic compilation on performance.

e) Garbage Collector: The Java Virtual Machine uses a Garbage Collector to manage memory at runtime. The Garbage Collector sometimes needs to interrupt the program execution. Identify if the cost of the Garbage Collector is relevant? Compare the file perfreport2.txt (run of the MULT class) and perfreport3.txt (run of the MULT_2 class). Why?

f) (*) Measure and compare Java with C: Fill the table with performance data collected with perf stat -M cpi ./a.out. Calculate the performance gain between the C and Java versions and comment the results.


   |   N | Version | Time | CPI | #I                 | L1_DMiss | Miss/#I |
   |     |         |      |     | (inst_retured.any) |          |         |
   | 512 | C       |      |     |                    |          |         |
   | 512 | Java    |      |     |                    |          |         |
